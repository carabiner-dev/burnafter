// SPDX-FileCopyrightText: Copyright 2025 Carabiner Systems, Inc
// SPDX-License-Identifier: Apache-2.0

package common

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"

	"golang.org/x/crypto/hkdf"
)

// DeriveKey derives a secret's encryption key from multiple inputs using HKDF
// The inputs used to derive the key are as follows:
//   - clientBinaryHash: The sha256 digest of the client binary.
//   - clientNonce: A value only known to the client application.
//   - serverSessionID: Random secret generated by the server
//   - secretName: Name of the secret
//   - salt: random salt
func DeriveKey(
	clientBinaryHash, clientNonce, serverSessionID, secretName string, salt []byte,
) ([]byte, error) {
	// Concatenate all inputs to create the input key material (IKM)
	ikm := []byte(clientBinaryHash + clientNonce + serverSessionID + secretName)

	// Use HKDF to derive a 32-byte key
	reader := hkdf.New(sha256.New, ikm, salt, []byte("burnafter-v1"))

	key := make([]byte, 32) // AES-256 requires 32 bytes
	if _, err := io.ReadFull(reader, key); err != nil {
		return nil, fmt.Errorf("failed to derive key: %w", err)
	}

	return key, nil
}

// GenerateSalt creates a random salt used when deriving the key
func GenerateSalt() ([]byte, error) {
	salt := make([]byte, 32)
	if _, err := rand.Read(salt); err != nil {
		return nil, fmt.Errorf("failed to generate salt: %w", err)
	}
	return salt, nil
}

// GenerateSessionID creates a random server session ID, this is the
// equivalent to the client nonce. This value is used to infer the
// secret key and it's lost when the server dies, rendering any encrypted
// secrets inaccesible.
func GenerateSessionID() (string, error) {
	sessionBytes := make([]byte, 32)
	if _, err := rand.Read(sessionBytes); err != nil {
		return "", fmt.Errorf("failed to generate session ID: %w", err)
	}
	return hex.EncodeToString(sessionBytes), nil
}

// Encrypt encrypts a plaintext string using AES-256-GCM with the provided key.
func Encrypt(plaintext string, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("creating cipher: %w", err)
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("creating GCM: %w", err)
	}

	// nonce for the encryption (not the client's)
	nonce := make([]byte, gcm.NonceSize())
	if _, err := rand.Read(nonce); err != nil {
		return nil, fmt.Errorf("generating nonce: %w", err)
	}

	// Encrypt the secret
	ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)
	return ciphertext, nil
}

// Decrypt decrypts ciphertext using AES-256-GCM with the provided key
func Decrypt(ciphertext, key []byte) (string, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return "", fmt.Errorf("creating cipher: %w", err)
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return "", fmt.Errorf("creating GCM: %w", err)
	}

	nonceSize := gcm.NonceSize()
	if len(ciphertext) < nonceSize {
		return "", fmt.Errorf("ciphertext too short")
	}

	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return "", fmt.Errorf("decrypting secret: %w", err)
	}

	return string(plaintext), nil
}

// ZeroBytes securely zeros out a byte slice to wipe out the secrets
func ZeroBytes(b []byte) {
	for i := range b {
		b[i] = 0
	}
}
